<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="es">
<head>
    <meta charset="UTF-8">
    <title>Grafo PageRank</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        h2 {
            position: absolute;
            top: 5px;
            left: 10px;
            margin: 0;
            padding: 0;
        }

        #graph {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<h2>Grafo PageRank</h1>
<div id="graph" ></div>

<script src="/webjars/d3/7.8.5/dist/d3.min.js"></script>
<script>
    const width = window.innerWidth || 1200;
    const height = window.innerHeight || 700;

    const svg = d3.select("#graph")
        .append("svg")
        .attr("width", "100dvw")
        .attr("height", "100dvh")
        .call(d3.zoom().scaleExtent([0.2, 5]).on("zoom", (event) => {
            g.attr("transform", event.transform);
        }));

    const g = svg.append("g");

    const defs = svg.append("defs");
    const markers = [
        { id: "arrow-default", color: "#777" },
        { id: "arrow-out", color: "#1976d2" },
        { id: "arrow-in", color: "#c2185b" },
        { id: "arrow-muted", color: "#dddddd" }
    ];
    markers.forEach(m => {
        defs.append("marker")
            .attr("id", m.id)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", m.color);
    });

    fetch("/api/graph")
        .then(r => r.json())
        .then(drawGraph);

    function drawGraph(data) {
        const nodes = data.nodes.map(d => Object.assign({}, d));
        const links = data.links.map(d => ({
            source: d.sourceId,
            target: d.targetId,
            weight: d.weight
        }));

        const scoreExtent = d3.extent(nodes, d => d.score);
        const radius = d3.scaleSqrt()
            .domain(scoreExtent[0] === scoreExtent[1] ? [0, 1] : scoreExtent)
            .range([10, 60]);

        const strength = d3.scaleLinear()
            .domain(d3.extent(links, d => d.weight))
            .range([0.1, 1]);

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(d => 350 + radius(d.source.score || 0) + radius(d.target.score || 0))
                .strength(d => strength(d.weight)))
            .force("charge", d3.forceManyBody().strength(-1000))
            .force("collision", d3.forceCollide().radius(d => radius(d.score) + 25))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const linkColor = "#888";
        const link = g.append("g")
            .attr("stroke", linkColor)
            .attr("stroke-opacity", 0.7)
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("class", d => `link source-${d.source.id} target-${d.target.id}`)
            .attr("stroke-width", d => 1)
            .attr("marker-end", "url(#arrow-default)");

        const node = g.append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .call(drag(simulation));

        node.append("circle")
            .attr("r", d => radius(d.score))
            .attr("fill", "#f28e2b")
            .attr("stroke", "#333");

        node.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("font-size", "10px")
            .text(d => `${d.name}`);

        node.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "1.5em")
            .attr("font-size", "12px")
            .text(d => `(${d.percentage.toFixed(2)}%)`);


        simulation.on("tick", () => {
            link
                .attr("x1", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const offset = radius(d.source.score || 0) + 2;
                    return d.source.x + (dx / dist) * offset;
                })
                .attr("y1", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const offset = radius(d.source.score || 0) + 2;
                    return d.source.y + (dy / dist) * offset;
                })
                .attr("x2", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const offset = radius(d.target.score || 0) + 4;
                    return d.target.x - (dx / dist) * offset;
                })
                .attr("y2", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const offset = radius(d.target.score || 0) + 4;
                    return d.target.y - (dy / dist) * offset;
                });

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        node.on("mouseover", function (event, d) {
            link
                .attr("stroke", l => {
                    if (l.source.id === d.id) return "#1976d2"; // salientes
                    if (l.target.id === d.id) return "#c2185b"; // entrantes
                    return "#ddd";
                })
                .attr("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 0.9 : 0.15)
                .attr("marker-end", l => {
                    if (l.source.id === d.id) return "url(#arrow-out)";
                    if (l.target.id === d.id) return "url(#arrow-in)";
                    return "url(#arrow-muted)";
                });
            const connectedIds = new Set();
            links.forEach(l => {
                if (l.source.id === d.id) {
                    connectedIds.add(l.target.id);
                }
                if (l.target.id === d.id) {
                    connectedIds.add(l.source.id);
                }
            });
            node.selectAll("circle")
                .attr("opacity", n => (n.id === d.id || connectedIds.has(n.id)) ? 1 : 0.3)
                .attr("stroke-opacity", n => (n.id === d.id) ? 1 : 0.5);
        }).on("mouseout", function () {
            link
                .attr("stroke", linkColor)
                .attr("stroke-opacity", 0.7)
                .attr("marker-end", "url(#arrow-default)");
            node.selectAll("circle").attr("opacity", 1).attr("stroke-opacity", 1);
        }).on("click", function (event, d) {
            if (event.defaultPrevented) {
                return;
            }
            window.location.href = "/follows/" + d.id;
        });
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }
</script>
</body>
</html>
